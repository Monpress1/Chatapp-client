 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Anonymous Chat</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<style>
  
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #e0e0e0;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

#messageArea {
  flex-grow: 1;
  padding: 15px;
  overflow-y: auto;
  background-color: #f9f9f9;
  border-radius: 10px 10px 0 0;
  margin: 10px;
  display: flex;
  flex-direction: column;
}

.message {
  padding: 10px 15px;
  margin-bottom: 8px;
  border-radius: 15px;
  max-width: 70%;
  animation: fadeIn 0.3s ease-in-out;
  clear: both;
  word-break: break-word;
  cursor: pointer;
  position: relative;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.sent {
  align-self: flex-end;
  background-color: #dcf8c6;
  color: #333;
}

.message.received {
  background-color: #fff;
  color: #333;
  align-self: flex-start;
}

.message.image-message {
  max-width: 60%;
}

.message.image-message img {
  width: 100%;
  height: auto;
  border-radius: 8px;
}

.message .timestamp {
  font-size: 0.75rem;
  color: #888;
  display: block;
  margin-top: 4px;
  text-align: right;
}

.display {
  display: flex;
  align-items: center;
  padding: 10px;
  background-color: #f0f0f0;
  border-top: 1px solid #ccc;
}

#messageInput {
  flex-grow: 1;
  padding: 10px;
  margin-right: 10px;
  border: 1px solid #ccc;
  border-radius: 20px;
}

button {
  padding: 10px 15px;
  border: none;
  border-radius: 20px;
  background-color: #007bff;
  color: white;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}

.image-upload-button {
  background: none;
  border: none;
  padding: 10px;
  margin-left: 5px;
  cursor: pointer;
  font-size: 24px;
  color: #555;
  outline: none;
}

.image-upload-button:hover {
  color: #007bff;
}

#imageUpload {
  display: none;
}

#loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 20px;
  border-radius: 10px;
  z-index: 9999;
  display: none;
}

.clear-history-button {
  background-color: #f44336;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 5px;
  cursor: pointer;
  margin: 10px auto;
  display: block;
}

.clear-history-button:hover {
  background-color: #d32f2f;
}

#notification {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #f9f1a5;
  color: #333;
  padding: 10px 20px;
  border-radius: 5px;
  opacity: 0.8;
  z-index: 1000;
  display: none;
}

/* Modal styles */
.modal {
  display: none;
  position: fixed;
  z-index: 10000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

.modal-content {
  background-color: #fefefe;
  margin: 10% auto;
  padding: 20px;
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

/* Highlight keyword colors */
.highlight-green {
  background-color: #a0d995;
  font-weight: bold;
  border-radius: 3px;
  padding: 0 2px;
}

.highlight-red {
  background-color: #f88383;
  font-weight: bold;
  border-radius: 3px;
  padding: 0 2px;
}

.highlight-yellow {
  background-color: #fff176;
  font-weight: bold;
  border-radius: 3px;
  padding: 0 2px;
}

/* New style for online count */
#onlineCountDisplay {
  position: fixed;
  top: 10px;
  left: 10px;
  background-color: #4CAF50; /* Green background */
  color: white;
  padding: 8px 12px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9em;
  font-weight: bold;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  z-index: 999;
}

#onlineCountDisplay:hover {
  background-color: #45a049;
}

/* Online Users List Modal */
#onlineUsersModal .modal-content ul {
    list-style: none;
    padding: 0;
}

#onlineUsersModal .modal-content li {
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}

#onlineUsersModal .modal-content li:last-child {
    border-bottom: none;
}

/* Profile Setup Modal specific styles */
#profileSetupModal .modal-content {
    text-align: left;
}

#profileSetupModal input[type="text"],
#profileSetupModal select {
    width: calc(100% - 22px); /* Account for padding */
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
}

#profileSetupModal fieldset {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 15px;
}

#profileSetupModal legend {
    font-weight: bold;
    padding: 0 5px;
}

#profileSetupModal label {
    display: block;
    margin-bottom: 8px;
}

#profileSetupModal button {
    width: 100%;
    padding: 12px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1.1em;
}

#profileSetupModal button:hover {
    background-color: #0056b3;
}

</style>
<body>
  <div id="loading">Loading...</div>

  <div id="onlineCountDisplay">
    Online: <span id="onlineCount">0</span>
  </div>

  <div id="messageArea"></div>

  <div class="display">
    <input type="text" id="messageInput" placeholder="Type a message..." />
    <button onclick="sendMessage()">Send</button>
    <button class="image-upload-button" onclick="document.getElementById('imageUpload').click()">+</button>
    <input type="file" id="imageUpload" accept="image/*" />
  </div>

  <button class="clear-history-button" onclick="clearLocalStorage()">Clear Chat History</button>

  <div id="notification"></div>

  <div id="profileSetupModal" class="modal">
    <div class="modal-content">
      <h2>Set up your profile</h2>
      <label for="profileUsername">Username:</label>
      <input id="profileUsername" type="text" maxlength="20" placeholder="Your name" required>

      <fieldset>
        <legend>Things you like:</legend>
        <label><input type="checkbox" name="likes" value="love"> Love</label>
        <label><input type="checkbox" name="likes" value="dogs"> Dogs</label>
        <label><input type="checkbox" name="likes" value="cats"> Cats</label>
        <label><input type="checkbox" name="likes" value="music"> Music</label>
        <label><input type="checkbox" name="likes" value="sex"> Sex</label>
        <label><input type="checkbox" name="likes" value="relationship"> Relationship</label>
      </fieldset>

      <label for="profileGender">Gender:</label>
      <select id="profileGender" required>
        <option value="" disabled selected>Select gender</option>
        <option value="Male">Male</option>
        <option value="Female">Female</option>
        <option value="Other">Other</option>
        <option value="Prefer not to say">Prefer not to say</option>
      </select>

      <label><input type="checkbox" id="profileAdult" required> I confirm I am over 18</label>
      
      <button onclick="saveProfile()">Save Profile</button>
    </div>
  </div>


  <div id="viewerModal" class="modal">
    <div class="modal-content">
      <h2>User Profile</h2>
      <p><strong>Username:</strong> <span id="viewerUsername"></span></p>
      <p><strong>Gender:</strong> <span id="viewerGender"></span></p>
      <p><strong>Likes:</strong> <span id="viewerLikes"></span></p>
      <button onclick="closeViewer()">Close</button>
    </div>
  </div>

  <div id="onlineUsersModal" class="modal">
    <div class="modal-content">
      <h2>Online Users (<span id="onlineUsersCountInModal">0</span>)</h2>
      <ul id="onlineUsersList">
        </ul>
      <button onclick="document.getElementById('onlineUsersModal').style.display='none'">Close</button>
    </div>
  </div>

  <script>
    
const ws = new WebSocket('wss://websocket-server-6jct.onrender.com'); // IMPORTANT: Replace with your actual server URL
const messageArea = document.getElementById('messageArea');
const messageInput = document.getElementById('messageInput');
const imageUpload = document.getElementById('imageUpload');
const loadingDiv = document.getElementById('loading');
const notificationDiv = document.getElementById('notification');
const onlineCountDisplay = document.getElementById('onlineCountDisplay'); 
const onlineCountSpan = document.getElementById('onlineCount'); 
const onlineUsersModal = document.getElementById('onlineUsersModal'); 
const onlineUsersList = document.getElementById('onlineUsersList'); 
const onlineUsersCountInModal = document.getElementById('onlineUsersCountInModal'); 

// Profile setup modal elements
const profileSetupModal = document.getElementById('profileSetupModal');
const profileUsernameInput = document.getElementById('profileUsername');
const profileGenderSelect = document.getElementById('profileGender');
const profileAdultCheckbox = document.getElementById('profileAdult');


let currentRoom = "anonymous";
let myProfile = null; // Will hold username, likes, gender, isAdult
let connectionReady = false;
const messageHistory = new Map(); // Tracks displayed message IDs to prevent duplicates
const messageQueue = new Map(); // Stores messages to send when connection is re-established

loadingDiv.style.display = 'block';

// Add event listener for the online count display
onlineCountDisplay.addEventListener('click', requestOnlineUserList);

// ----- USER PROFILE MODAL (Initial Setup) -----
function showProfileSetupModal() {
  profileSetupModal.style.display = 'flex'; // Show the modal
  // Clear any previous inputs for a clean start
  profileUsernameInput.value = '';
  profileGenderSelect.value = ''; // Reset select to default option
  profileAdultCheckbox.checked = false;
  const likesCheckboxes = profileSetupModal.querySelectorAll('input[name="likes"]');
  likesCheckboxes.forEach(cb => cb.checked = false);
}

function saveProfile() {
  const username = profileUsernameInput.value.trim();
  const gender = profileGenderSelect.value;
  const adultCheckbox = profileAdultCheckbox.checked;
  const likesCheckboxes = profileSetupModal.querySelectorAll('input[name="likes"]:checked');
  const likes = Array.from(likesCheckboxes).map(cb => cb.value);

  if (!username) {
    alert('Please enter a username.');
    return;
  }
  if (!gender) {
    alert('Please select your gender.');
    return;
  }
  if (!adultCheckbox) {
    alert('You must confirm you are over 18.');
    return;
  }

  myProfile = { username, gender, likes, isAdult: adultCheckbox };
  localStorage.setItem('myProfile', JSON.stringify(myProfile));
  profileSetupModal.style.display = 'none'; // Hide modal
  initWebSocket(); // Initialize WebSocket after profile is set
}

// Load profile from localStorage or show modal
function loadOrCreateProfile() {
  const savedProfile = localStorage.getItem('myProfile');
  if (savedProfile) {
    myProfile = JSON.parse(savedProfile);
    initWebSocket();
  } else {
    showProfileSetupModal();
  }
}

// ----- WEBSOCKET AND CHAT HANDLERS -----
function initWebSocket() {
  ws.onopen = () => {
    console.log('Connected to WebSocket server!');
    connectionReady = true;
    loadingDiv.style.display = 'none';
    joinRoom(currentRoom);
    deliverQueuedMessages();
    requestOnlineUserList(); // Request initial online count/list
  };

  ws.onmessage = (event) => {
    try {
      const message = JSON.parse(event.data);
      
      if (message.type === 'overallOnlineCount') {
          updateOnlineCount(message.count);
      } else if (message.type === 'overallUserList') {
          displayOnlineUserList(message.users);
      } else if (message.room === currentRoom) { // Process messages for the current room
        handleIncomingMessage(message);
      }
    } catch (err) {
      console.error('Error parsing message:', err);
    }
  };

  ws.onerror = (error) => {
    console.error('WebSocket error:', error);
    loadingDiv.style.display = 'block';
    showNotification('WebSocket connection error. Trying to reconnect...');
  };

  ws.onclose = () => {
    console.log('Disconnected from WebSocket');
    connectionReady = false;
    loadingDiv.style.display = 'block';
    updateOnlineCount(0); // Set count to 0 on disconnect
    showNotification('Disconnected. Attempting to reconnect in 3 seconds...');
    setTimeout(reconnectWebSocket, 3000); // Attempt to reconnect after a delay
  };
}

function reconnectWebSocket() {
    if (!connectionReady) { // Only try to reconnect if not already connected
        console.log('Attempting to reconnect...');
        const newWs = new WebSocket('wss://websocket-server-6jct.onrender.com'); // Replace with your server URL
        // Re-assign event handlers to the new WebSocket instance
        newWs.onopen = ws.onopen;
        newWs.onmessage = ws.onmessage;
        newWs.onerror = ws.onerror;
        newWs.onclose = ws.onclose;
        ws = newWs; // Update the global ws variable
    }
}


function joinRoom(roomId) {
  if (!connectionReady) return;
  // Ensure profile is sent with the join message
  ws.send(JSON.stringify({ type: 'join', room: roomId, user: myProfile.username, profile: myProfile })); 
  messageArea.innerHTML = "";
  showNotification(`Joined room: ${roomId}`);
  loadMessagesFromLocalStorage();
}

function handleIncomingMessage(message) {
  const { type, sender, content, data, id, senderProfile, timestamp } = message; 
  if (!id) return;

  // IMPORTANT FIX: Always check messageHistory first to prevent duplicates
  if (messageHistory.has(id)) {
      console.log(`Duplicate message received (ID: ${id}). Skipping display.`);
      return; 
  }
  // If it's a new message, mark it as processed
  messageHistory.set(id, true); 

  const isSentByMe = sender === myProfile.username;

  // Display the message ONLY if it's NOT sent by the current user.
  // Our own sent messages are displayed immediately in sendMessage/sendImage.
  if (!isSentByMe) { 
    if (type === 'message') {
      displayMessage(content, isSentByMe, id, sender, senderProfile, timestamp); 
      saveMessageToLocalStorage(message); // Only save received messages
    } else if (type === 'image') {
      displayImage(data, isSentByMe, id, sender, senderProfile, timestamp); 
      saveMessageToLocalStorage(message); // Only save received images
    }
  }
}


// ----- DISPLAY FUNCTIONS -----
function highlightKeywords(text) {
  const keywords = {
    love: "green",
    money: "green",
    home: "green",
    monpress: "green",
    "mide sensational": "green",
    eksu: "green",
    fuck: "red",
    danger: "red",
    warning: "red",
    sad: "red",
    sex: "red",
    kill: "yellow",
  };

  let result = text;

  for (const [keyword, color] of Object.entries(keywords)) {
    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
    result = result.replace(regex, match => `<span class="highlight-${color}">${match}</span>`); // Use class
  }
  return result;
}

function displayMessage(text, isSent, id, sender, profile = {}, timestamp = null) {
  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message', isSent ? 'sent' : 'received');
  msgDiv.dataset.sender = sender;
  msgDiv.dataset.profile = JSON.stringify(profile);
  msgDiv.dataset.timestamp = timestamp || new Date().toISOString();

  const highlightedText = highlightKeywords(text);
  msgDiv.innerHTML = `<strong>${sender}</strong>: ${highlightedText}`;

  const timeSpan = document.createElement('span');
  timeSpan.classList.add('timestamp');
  timeSpan.textContent = new Date(msgDiv.dataset.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // Format time
  msgDiv.appendChild(timeSpan);

  messageArea.appendChild(msgDiv);
  messageArea.scrollTop = messageArea.scrollHeight;

  // Add click listener to show profile modal for received messages
  if (!isSent) { 
    msgDiv.onclick = () => showUserProfileModal(sender, profile);
  }
}


function displayImage(base64, isSent, id, sender, profile = {}, timestamp = null) {
  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message', isSent ? 'sent' : 'received', 'image-message');
  msgDiv.dataset.sender = sender;
  msgDiv.dataset.profile = JSON.stringify(profile);
  msgDiv.dataset.timestamp = timestamp || new Date().toISOString();

  msgDiv.innerHTML = `<strong>${sender}</strong> sent an image:<br>`;
  const img = document.createElement('img');
  img.src = `data:image/png;base64,${base64}`;
  img.style.maxWidth = '100%';
  img.style.borderRadius = '8px';
  msgDiv.appendChild(img);

  const timeSpan = document.createElement('span');
  timeSpan.classList.add('timestamp');
  timeSpan.textContent = new Date(msgDiv.dataset.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // Format time
  msgDiv.appendChild(timeSpan);

  messageArea.appendChild(msgDiv);
  messageArea.scrollTop = messageArea.scrollHeight;

  // Add click listener to show profile modal for received images
  if (!isSent) { 
    msgDiv.onclick = () => showUserProfileModal(sender, profile);
  }
}

// ----- PROFILE MODAL ON MESSAGE CLICK -----
function showUserProfileModal(username, profile = {}) {
  // Ensure profile is not null or undefined
  profile = profile || {}; 
  const { gender = 'Unknown', likes = [] } = profile;
  const likesList = likes.length ? likes.join(', ') : 'No likes specified';

  const modalHTML = `
    <div id="userProfileViewModal" class="modal" style="display:flex;">
      <div class="modal-content">
        <h3>${username}'s Profile</h3>
        <p><strong>Gender:</strong> ${gender}</p>
        <p><strong>Likes:</strong> ${likesList}</p>
        <button id="closeProfileViewBtn">Close</button>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHTML);
  document.getElementById('closeProfileViewBtn').onclick = () => {
    document.getElementById('userProfileViewModal').remove();
  };
}

// ----- LOCAL STORAGE -----
function saveMessageToLocalStorage(message) {
  if (!currentRoom) return;
  const key = `messages_${currentRoom}`;
  let stored = JSON.parse(localStorage.getItem(key)) || [];
  
  // This function is only called for RECEIVED messages by handleIncomingMessage,
  // so no need to check `message.sender === myProfile.username` here.
  stored.push(message);
  localStorage.setItem(key, JSON.stringify(stored));
}

function loadMessagesFromLocalStorage() {
  if (!currentRoom) return;
  const key = `messages_${currentRoom}`;
  const stored = JSON.parse(localStorage.getItem(key)) || [];
  messageArea.innerHTML = ''; // Clear existing messages before loading
  messageHistory.clear(); // Clear the in-memory history before loading from storage

  stored.forEach(msg => {
    // Only display messages from storage that were NOT sent by me.
    // My own sent messages are handled by immediate display and then server echo.
    const isSent = msg.sender === myProfile.username;
    if (!isSent) { 
      // Add loaded message ID to history to prevent re-display if echoed later
      messageHistory.set(msg.id, true); 
      if (msg.type === 'message') {
        displayMessage(msg.content, isSent, msg.id, msg.sender, msg.profile || msg.senderProfile, msg.timestamp); 
      } else if (msg.type === 'image') {
        displayImage(msg.data, isSent, msg.id, msg.sender, msg.profile || msg.senderProfile, msg.timestamp); 
      }
    }
  });
}

// ----- SEND MESSAGE & IMAGE -----
function sendMessage() {
  const content = messageInput.value.trim();
  if (!content) return;

  const msgId = generateMessageId();
  const timestamp = new Date().toISOString();

  const message = {
    type: 'message',
    room: currentRoom,
    content,
    sender: myProfile.username,
    id: msgId,
    profile: myProfile, 
    timestamp
  };

  if (connectionReady) {
    ws.send(JSON.stringify(message));
    // Immediately display the message for the sender.
    // Add its ID to history to ensure the server's echo won't cause a duplicate.
    if (!messageHistory.has(msgId)) { 
        messageHistory.set(msgId, true);
        displayMessage(content, true, msgId, myProfile.username, myProfile, timestamp); 
    }
  } else {
    queueMessage(message);
    // Display message for the sender even if queued, with a notification.
    if (!messageHistory.has(msgId)) {
      messageHistory.set(msgId, true);
      displayMessage(content, true, msgId, myProfile.username, myProfile, timestamp);
    }
  }

  messageInput.value = '';
}

function sendImage(base64) {
  if (!connectionReady) return;

  const msgId = generateMessageId();
  const timestamp = new Date().toISOString();

  const message = {
    type: 'image',
    room: currentRoom,
    data: base64,
    sender: myProfile.username,
    id: msgId,
    profile: myProfile, 
    timestamp
  };

  if (connectionReady) {
    ws.send(JSON.stringify(message));
    // Immediately display the image for the sender.
    // Add its ID to history to ensure the server's echo won't cause a duplicate.
    if (!messageHistory.has(msgId)) { 
        messageHistory.set(msgId, true);
        displayImage(base64, true, msgId, myProfile.username, myProfile, timestamp); 
    }
  } else {
    queueMessage(message);
    // Display image for the sender even if queued, with a notification.
    if (!messageHistory.has(msgId)) {
      messageHistory.set(msgId, true);
      displayImage(base64, true, msgId, myProfile.username, myProfile, timestamp);
    }
  }
}

// Message queueing functions
function queueMessage(message) {
  const username = message.sender;
  if (!messageQueue.has(username)) {
    messageQueue.set(username, []);
  }
  messageQueue.get(username).push(message);
  // message.id is already added to messageHistory in sendMessage/sendImage
  showNotification('Connection lost. Message queued. Will send when reconnected.');
}

function deliverQueuedMessages() {
  if (myProfile && messageQueue.has(myProfile.username)) { 
    const queuedMessages = messageQueue.get(myProfile.username);
    queuedMessages.forEach(message => {
      ws.send(JSON.stringify(message));
      // Message was already displayed when queued (and ID added to history).
      // No need to display again. The server echo will be blocked by history.
    });
    messageQueue.delete(myProfile.username);
    showNotification('Queued messages sent!');
  }
}

// ----- NEW: ONLINE COUNT AND LIST FUNCTIONS -----

function updateOnlineCount(count) {
    onlineCountSpan.textContent = count;
    onlineUsersCountInModal.textContent = count;
}

function requestOnlineUserList() {
    if (connectionReady) {
        ws.send(JSON.stringify({ type: 'requestOnlineUsers' }));
    }
}

function displayOnlineUserList(users) {
    onlineUsersList.innerHTML = ''; // Clear previous list
    if (users.length === 0) {
        const li = document.createElement('li');
        li.textContent = 'No other users online.';
        onlineUsersList.appendChild(li);
    } else {
        users.forEach(username => {
            const li = document.createElement('li');
            li.textContent = username;
            onlineUsersList.appendChild(li);
        });
    }
    onlineUsersModal.style.display = 'flex'; // Use 'flex' for modals
}

// ----- UTILS -----
function generateMessageId() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0,
      v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function showNotification(msg) {
  notificationDiv.textContent = msg;
  notificationDiv.style.display = 'block';
  setTimeout(() => {
    notificationDiv.style.display = 'none';
  }, 3000);
}

function clearLocalStorage() {
  localStorage.removeItem(`messages_${currentRoom}`);
  messageArea.innerHTML = '';
  showNotification('Chat history cleared.');
  messageHistory.clear(); // Also clear the in-memory history
}

// ----- IMAGE UPLOAD HANDLER -----
imageUpload.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onloadend = () => {
    const base64 = reader.result.split(',')[1];
    sendImage(base64);
  };
  reader.readAsDataURL(file);
  e.target.value = null;
});

// ----- INITIALIZATION -----
loadOrCreateProfile();

// Expose functions to global scope for HTML onclick
window.sendMessage = sendMessage;
window.clearLocalStorage = clearLocalStorage;
window.saveProfile = saveProfile; // Expose saveProfile for the modal button

  </script>
</body>
</html>
