 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Anonymous Chat</title>
  </head>
<style>
  /* --- Styles (as provided by you) --- */
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #e0e0e0;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

#messageArea {
  flex-grow: 1;
  padding: 15px;
  overflow-y: auto;
  background-color: #f9f9f9;
  border-radius: 10px 10px 0 0;
  margin: 10px;
  display: flex;
  flex-direction: column;
}

.message {
  padding: 10px 15px;
  margin-bottom: 8px;
  border-radius: 15px;
  max-width: 70%;
  animation: fadeIn 0.3s ease-in-out;
  clear: both;
  word-break: break-word;
  cursor: pointer;
  position: relative;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.sent {
  align-self: flex-end;
  background-color: #dcf8c6;
  color: #333;
}

.message.received {
  background-color: #fff;
  color: #333;
  align-self: flex-start;
}

.message.image-message {
  max-width: 60%;
}

.message.image-message img {
  width: 100%;
  height: auto;
  border-radius: 8px;
}

.message .timestamp {
  font-size: 0.75rem;
  color: #888;
  display: block;
  margin-top: 4px;
  text-align: right;
}

.display {
  display: flex;
  align-items: center;
  padding: 10px;
  background-color: #f0f0f0;
  border-top: 1px solid #ccc;
}

#messageInput {
  flex-grow: 1;
  padding: 10px;
  margin-right: 10px;
  border: 1px solid #ccc;
  border-radius: 20px;
}

button {
  padding: 10px 15px;
  border: none;
  border-radius: 20px;
  background-color: #007bff;
  color: white;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}

.image-upload-button {
  background: none;
  border: none;
  padding: 10px;
  margin-left: 5px;
  cursor: pointer;
  font-size: 24px;
  color: #555;
  outline: none;
}

.image-upload-button:hover {
  color: #007bff;
}

#imageUpload {
  display: none;
}

#loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 20px;
  border-radius: 10px;
  z-index: 9999;
  display: none;
}

.clear-history-button {
  background-color: #f44336;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 5px;
  cursor: pointer;
  margin: 10px auto;
  display: block;
}

.clear-history-button:hover {
  background-color: #d32f2f;
}

#notification {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #f9f1a5;
  color: #333;
  padding: 10px 20px;
  border-radius: 5px;
  opacity: 0.8;
  z-index: 1000;
  display: none;
}

/* Modal styles */
.modal {
  display: none;
  position: fixed;
  z-index: 10000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

.modal-content {
  background-color: #fefefe;
  margin: 10% auto;
  padding: 20px;
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

/* Highlight keyword colors */
.highlight-green {
  background-color: #a0d995;
  font-weight: bold;
  border-radius: 3px;
  padding: 0 2px;
}

.highlight-red {
  background-color: #f88383;
  font-weight: bold;
  border-radius: 3px;
  padding: 0 2px;
}

.highlight-yellow {
  background-color: #fff176;
  font-weight: bold;
  border-radius: 3px;
  padding: 0 2px;
}
</style>
<body>
  <div id="loading">Loading...</div>

  <div id="messageArea"></div>

  <div class="display">
    <input type="text" id="messageInput" placeholder="Type a message..." />
    <button onclick="sendMessage()">Send</button>
    <button class="image-upload-button" onclick="document.getElementById('imageUpload').click()">+</button>
    <input type="file" id="imageUpload" accept="image/*" />
  </div>

  <button class="clear-history-button" onclick="clearLocalStorage()">Clear Chat History</button>

  <div id="notification"></div>

  <div id="profileModal" class="modal">
    <div class="modal-content">
      <h2>Enter Your Profile</h2>
      <input type="text" id="usernameInput" placeholder="Enter your username" />

      <div>
        <p>What do you like?</p>
        <label><input type="checkbox" value="love" /> Love</label>
        <label><input type="checkbox" value="dogs" /> Dogs</label>
        <label><input type="checkbox" value="cats" /> Cats</label>
        <label><input type="checkbox" value="music" /> Music</label>
        <label><input type="checkbox" value="sex" /> Sex</label>
        <label><input type="checkbox" value="relationship" /> Relationship</label>
      </div>

      <div>
        <p>Your Gender:</p>
        <select id="genderSelect">
          <option value="prefer_not_say">Prefer not to say</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="other">Other</option>
        </select>
      </div>

      <label><input type="checkbox" id="ageConfirm" /> I confirm I'm above 18</label>
      <br />
      <button onclick="submitProfile()">Continue</button>
    </div>
  </div>

  <div id="viewerModal" class="modal">
    <div class="modal-content">
      <h2>User Profile</h2>
      <p><strong>Username:</strong> <span id="viewerUsername"></span></p>
      <p><strong>Gender:</strong> <span id="viewerGender"></span></p>
      <p><strong>Likes:</strong> <span id="viewerLikes"></span></p>
      <button onclick="closeViewer()">Close</button>
    </div>
  </div>

  <script>
    // --- IMPORTANT: This URL has been updated with your Render server URL ---
    const API_BASE_URL = 'https://websocket-server-6jct.onrender.com'; 
    const WS_URL = API_BASE_URL.replace('https://', 'wss://'); // Derive WebSocket URL

    const ws = new WebSocket(WS_URL);
    const messageArea = document.getElementById('messageArea');
    const messageInput = document.getElementById('messageInput');
    const imageUpload = document.getElementById('imageUpload');
    const loadingDiv = document.getElementById('loading');
    const notificationDiv = document.getElementById('notification');

    let currentRoom = "anonymous";
    let myProfile = null; // Will hold username, likes, gender, isAdult
    let connectionReady = false;
    const messageHistory = new Map(); // Tracks message IDs already displayed to avoid duplicates

    loadingDiv.style.display = 'block';

    // ----- USER PROFILE MODAL -----
    const profileModal = document.getElementById('profileModal');
    const usernameInput = document.getElementById('usernameInput');
    const genderSelect = document.getElementById('genderSelect');
    const ageConfirm = document.getElementById('ageConfirm');

    // Function to submit profile from the initial modal
    window.submitProfile = () => { // Make it a global function for onclick
        const username = usernameInput.value.trim();
        const gender = genderSelect.value;
        const adultCheckbox = ageConfirm.checked;
        const likesCheckboxes = profileModal.querySelectorAll('input[type=checkbox]:not(#ageConfirm):checked');
        const likes = Array.from(likesCheckboxes).map(cb => cb.value);

        if (!username) {
            alert('Please enter a username.');
            return;
        }
        if (!gender || gender === "prefer_not_say") { // Ensure a selection other than default
            alert('Please select your gender.');
            return;
        }
        if (!adultCheckbox) {
            alert('You must confirm you are over 18.');
            return;
        }

        myProfile = { username, gender, likes, isAdult: adultCheckbox };
        localStorage.setItem('myProfile', JSON.stringify(myProfile));
        profileModal.style.display = 'none'; // Hide the modal
        initWebSocket(); // Initialize WebSocket connection after profile is set
    };

    function showProfileModal() {
        profileModal.style.display = 'flex'; // Use flex to center
    }

    // Load profile from localStorage or show modal
    function loadOrCreateProfile() {
        const savedProfile = localStorage.getItem('myProfile');
        if (savedProfile) {
            myProfile = JSON.parse(savedProfile);
            initWebSocket();
        } else {
            showProfileModal();
        }
    }

    // ----- WEBSOCKET AND CHAT HANDLERS -----
    function initWebSocket() {
        ws.onopen = () => {
            console.log('Connected to WebSocket server!');
            connectionReady = true;
            loadingDiv.style.display = 'none';
            joinRoom(currentRoom);
        };

        ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                if (message.room === currentRoom) {
                    if (message.type === 'history') {
                        // Clear current messages and load history from server
                        messageArea.innerHTML = "";
                        messageHistory.clear(); // Clear tracking map for new history
                        message.messages.forEach(msg => {
                            // History can contain messages sent by 'me' from a previous session
                            const isSentByMe = msg.sender === myProfile.username; 
                            if (msg.type === 'message') {
                                displayMessage(msg.content, isSentByMe, msg.id, msg.sender, msg.profile, msg.timestamp);
                            } else if (msg.type === 'image') {
                                // For images from history, server sends imageUrl
                                displayImage(msg.imageUrl, isSentByMe, msg.id, msg.sender, msg.profile, msg.timestamp);
                            }
                            messageHistory.set(msg.id, true); // Mark as displayed
                            // We don't save history to localStorage here to avoid re-saving the entire history from the server repeatedly.
                            // Local storage will now only accumulate new messages sent/received *after* the initial history load.
                        });
                        messageArea.scrollTop = messageArea.scrollHeight; // Scroll to bottom
                        showNotification('Chat history loaded.');
                        console.log(`Loaded ${message.messages.length} messages from server history.`);

                    } else if (message.type === 'message' || message.type === 'image') {
                        // Handle real-time messages
                        handleIncomingRealtimeMessage(message);
                    }
                    // You could add handlers for 'population', 'userList' etc. here if needed
                }
            } catch (err) {
                console.error('Error parsing or handling WebSocket message:', err);
            }
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            loadingDiv.textContent = 'Connection Error. Retrying...';
            loadingDiv.style.display = 'block';
            connectionReady = false;
        };

        ws.onclose = () => {
            console.log('Disconnected from WebSocket. Attempting to reconnect in 5 seconds...');
            connectionReady = false;
            loadingDiv.textContent = 'Disconnected. Reconnecting...';
            loadingDiv.style.display = 'block';
            setTimeout(initWebSocket, 5000); // Attempt to reconnect after 5 seconds
        };
    }

    function joinRoom(roomId) {
        if (!connectionReady) return;
        ws.send(JSON.stringify({ type: 'join', room: roomId, user: myProfile.username, profile: myProfile }));
        // Do NOT clear messageArea or load from localStorage here.
        // The server will send the history, which will clear/populate the messageArea.
        showNotification(`Joining room: ${roomId}`);
    }

    // New function to handle real-time incoming messages
    function handleIncomingRealtimeMessage(message) {
        const { type, sender, content, imageUrl, id, profile, timestamp } = message; 
        if (!id) return;

        // Skip duplicate if already displayed (e.g., self-sent message that was displayed instantly)
        if (messageHistory.has(id)) return;
        messageHistory.set(id, true); // Mark as processed

        const isSentByMe = sender === myProfile.username;

        // Display messages from other users in real-time.
        // Messages sent by 'myself' are displayed instantly by sendMessage/sendImage functions,
        // so we skip the echo from the server to prevent duplicates.
        if (!isSentByMe) { 
            if (type === 'message') {
                displayMessage(content, isSentByMe, id, sender, profile, timestamp);
            } else if (type === 'image') {
                // For incoming images from server, use imageUrl
                displayImage(imageUrl, isSentByMe, id, sender, profile, timestamp);
            }
            saveMessageToLocalStorage(message); // Save newly received messages to local storage
        }
    }


    // ----- DISPLAY FUNCTIONS -----
    function highlightKeywords(text) {
        const keywords = {
            love: "green",
            money: "green",
            home: "green",
            monpress: "green",
            "mide sensational": "green",
            eksu: "green",
            fuck: "red",
            danger: "red",
            warning: "red",
            sad: "red",
            sex: "red",
            kill: "yellow",
        };

        let result = text;
        for (const [keyword, color] of Object.entries(keywords)) {
            const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
            result = result.replace(regex, match => `<span class="highlight-${color}">${match}</span>`);
        }
        return result;
    }

    function displayMessage(text, isSent, id, sender, profile = {}, timestamp = null) {
        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', isSent ? 'sent' : 'received');
        msgDiv.dataset.sender = sender;
        msgDiv.dataset.profile = JSON.stringify(profile);
        msgDiv.dataset.timestamp = timestamp || new Date().toISOString();

        const highlightedText = highlightKeywords(text);
        msgDiv.innerHTML = `<strong>${sender}</strong>: ${highlightedText}`;

        const timeSpan = document.createElement('span');
        timeSpan.classList.add('timestamp');
        timeSpan.textContent = new Date(msgDiv.dataset.timestamp).toLocaleTimeString();
        msgDiv.appendChild(timeSpan);

        messageArea.appendChild(msgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;

        // Add click listener to show profile modal
        msgDiv.onclick = () => showUserProfileModal(sender, profile);
    }

    // Modified displayImage to handle both base64 (for sent) and imageUrl (for received)
    function displayImage(imageSource, isSent, id, sender, profile = {}, timestamp = null) {
        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', isSent ? 'sent' : 'received', 'image-message');
        msgDiv.dataset.sender = sender;
        msgDiv.dataset.profile = JSON.stringify(profile);
        msgDiv.dataset.timestamp = timestamp || new Date().toISOString();

        msgDiv.innerHTML = `<strong>${sender}</strong> sent an image:<br>`;
        const img = document.createElement('img');

        if (isSent) {
            // When *sending* an image, `imageSource` is base64 (for immediate local display)
            img.src = `data:image/png;base64,${imageSource}`;
        } else {
            // When *receiving* an image from the server (either real-time or history),
            // `imageSource` is the URL relative to the server.
            // We prepend API_BASE_URL to form the full URL.
            img.src = `${API_BASE_URL}${imageSource}`; 
        }
        
        img.style.maxWidth = '100%';
        img.style.borderRadius = '8px';
        msgDiv.appendChild(img);

        const timeSpan = document.createElement('span');
        timeSpan.classList.add('timestamp');
        timeSpan.textContent = new Date(msgDiv.dataset.timestamp).toLocaleTimeString();
        msgDiv.appendChild(timeSpan);

        messageArea.appendChild(msgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;

        msgDiv.onclick = () => showUserProfileModal(sender, profile);
    }

    // ----- PROFILE MODAL ON MESSAGE CLICK -----
    const viewerModal = document.getElementById('viewerModal');
    const viewerUsernameSpan = document.getElementById('viewerUsername');
    const viewerGenderSpan = document.getElementById('viewerGender');
    const viewerLikesSpan = document.getElementById('viewerLikes');

    function showUserProfileModal(username, profile = {}) {
        const { gender = 'Unknown', likes = [] } = profile;
        const likesList = likes.length ? likes.join(', ') : 'No likes specified';

        viewerUsernameSpan.textContent = username;
        viewerGenderSpan.textContent = gender;
        viewerLikesSpan.textContent = likesList;
        viewerModal.style.display = 'flex'; // Show modal
    }

    window.closeViewer = () => { // Make global for onclick
        viewerModal.style.display = 'none'; // Hide modal
    };


    // ----- LOCAL STORAGE (Only for newly received messages now) -----
    // This will now only save messages received *after* the initial history load
    // from the server, or messages sent by yourself.
    function saveMessageToLocalStorage(message) {
        if (!currentRoom) return;
        const key = `messages_${currentRoom}`;
        let stored = JSON.parse(localStorage.getItem(key)) || [];
        // Prevent duplicates from history loading from being saved twice
        if (!stored.some(msg => msg.id === message.id)) {
            stored.push(message);
            localStorage.setItem(key, JSON.stringify(stored));
        }
    }

    // This function is now largely obsolete as server provides history on connect.
    // It's kept for potential future use or if you want to fall back to purely local.
    function loadMessagesFromLocalStorage() {
        // This function is not explicitly called after `joinRoom` in the new `initWebSocket`.
        // The `ws.onmessage` `type === 'history'` block handles the primary display of past messages.
    }


    // ----- SEND MESSAGE & IMAGE -----
    function sendMessage() {
        const content = messageInput.value.trim();
        if (!content || !connectionReady) return;

        const msgId = generateMessageId();
        const timestamp = new Date().toISOString();

        const message = {
            type: 'message',
            room: currentRoom,
            content,
            sender: myProfile.username,
            id: msgId,
            profile: myProfile, // Ensure 'profile' field matches server's 'profile' expectation
            timestamp
        };

        ws.send(JSON.stringify(message));
        displayMessage(content, true, msgId, myProfile.username, myProfile, timestamp); // Display immediately
        saveMessageToLocalStorage(message); // Save sent message to local storage

        messageInput.value = '';
    }

    function sendImage(base64, filename = 'image.png') { // Added filename parameter
        if (!connectionReady) return;

        const msgId = generateMessageId();
        const timestamp = new Date().toISOString();

        const message = {
            type: 'image',
            room: currentRoom,
            data: base64, // Send base64 to server
            filename: filename, // Send filename to server
            sender: myProfile.username,
            id: msgId,
            profile: myProfile,
            timestamp
        };

        ws.send(JSON.stringify(message));
        displayImage(base64, true, msgId, myProfile.username, myProfile, timestamp); // Display immediately (base64)
        // Image messages from server will have imageUrl, save this version for local storage for now.
        // Consider if you want to store the URL in local storage instead of base64 if server provides it.
        saveMessageToLocalStorage(message); 
    }

    // ----- UTILS -----
    function generateMessageId() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0,
                v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    function showNotification(msg) {
        notificationDiv.textContent = msg;
        notificationDiv.style.display = 'block';
        setTimeout(() => {
            notificationDiv.style.display = 'none';
        }, 3000);
    }

    // Clear client-side stored history
    window.clearLocalStorage = () => { // Make global for onclick
        localStorage.removeItem(`messages_${currentRoom}`);
        messageArea.innerHTML = '';
        messageHistory.clear(); // Clear the map too
        showNotification('Chat history cleared from browser.');
    };

    // ----- IMAGE UPLOAD HANDLER -----
    imageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // Add a simple check for file type
        if (!file.type.startsWith('image/')) {
            alert('Please select an image file.');
            e.target.value = null;
            return;
        }

        const reader = new FileReader();
        reader.onloadend = () => {
            const base64 = reader.result.split(',')[1];
            sendImage(base64, file.name); // Pass filename to sendImage
        };
        reader.readAsDataURL(file);
        e.target.value = null; // Clear the input so same file can be selected again
    });

    // ----- INITIALIZATION -----
    loadOrCreateProfile(); // This will eventually call initWebSocket
  </script>
</body>
</html>
